//========================================================//
//     Copyright 2006-2010, Analytical Graphics, Inc.     //
//========================================================//
using Microsoft.Win32;
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

using AGI.Attr;
using AGI.Plugin;
using AGI.Search;
using AGI.STK.Plugin;
using AGI.SearchControlReal.Plugin.Examples.CSharp.BisectionControlReal;
using AGI.SearchResult.Plugin.Examples.CSharp.BisectionResult;

namespace AGI.Search.Plugin.Examples.CSharp.Bisection
{
	/// <summary>
	/// Bisection search example
	/// </summary>
	// NOTE: Generate your own Guid using Microsoft's GuidGen.exe
	[Guid("429F13B0-2975-4dfb-875A-C6E59E8F72C7")]
	// NOTE: Create your own ProgId to match your plugin's namespace and name
	[ProgId("AGI.Search.Plugin.Examples.CSharp.Bisection")]
	// NOTE: Specify the ClassInterfaceType.None enumeration, so the custom COM Interface 
	// you created, i.e. IExample1, is used instead of an autogenerated COM Interface.
	[ClassInterface(ClassInterfaceType.None)]
	public class BisectionPlugin :
		IBisectionPlugin,
		IAgPluginSearch,
		IAgUtPluginConfig
	{
		#region Data Members

		private IAgUtPluginSite					m_UtPluginSite	= null;
		private object							m_AttrScope		= null;

		#endregion
		
		#region Life Cycle Methods
		/// <summary>
		/// Constructor
		/// </summary>
		public BisectionPlugin()
		{
			try
			{
				Debug.WriteLine( "Entered", "BisectionPlugin()");

			}
			finally
			{
				Debug.WriteLine( "Exited", "BisectionPlugin()");
			}
		}

		/// <summary>
		/// Destructor
		/// </summary>
		~BisectionPlugin()
		{
			try
			{
				Debug.WriteLine( "Entered", "~BisectionPlugin()");
			}
			finally
			{
				Debug.WriteLine( "Exited", "~BisectionPlugin()");
			}
		}

		private void Message( AgEUtLogMsgType msgType, string msg )
		{
			if( this.m_UtPluginSite != null )
			{
				this.m_UtPluginSite.Message( msgType, msg );
			}
		}
		#endregion

		#region IBisectionPlugin Interface Implementation

		private string	m_Name		= "AGI.Search.Plugin.Examples.CSharp.Bisection"; // Plugin Significant
		private int		m_maxIters	= 100;
		private string  m_realControlsProgID = "AGI.SearchControlReal.Plugin.Examples.CSharp.BisectionControlReal";
		private string	m_resultsProgID	 = "AGI.SearchResult.Plugin.Examples.CSharp.BisectionResult";
		public string Name
		{
			get
			{
				return this.m_Name;
			}
			set
			{
				this.m_Name = value;
			}
		}

		public int MaxIterations
		{
			get
			{
				return this.m_maxIters;
			}
			set
			{
				Debug.WriteLine( "New( "+this.GetHashCode()+" ) MaxIterations: " + value );
				this.m_maxIters = value;
			}
		}

		#endregion

		#region IAgPluginSearch Interface Implementation
		public bool Init( IAgUtPluginSite site)
		{
			this.m_UtPluginSite = site;

			if (this.m_UtPluginSite == null)
			{
				return false;
			}
	
			return true;
		}

		public bool Run( AgSearchPluginOperand operand, ref bool testing )
		{
			if( operand != null )
			{
				// get the first active control and result
				IAgSearchControlCollection controls = operand.Controls;

				BisectionControlReal control = null;
                int controlIndex = 0;

				for (int i = 0; i < controls.Count; ++i)
				{
					control = (BisectionControlReal)controls[i];
					if ( control != null && control.IsActive )
					{
                        controlIndex = i;
						break;
					}
					control = null;
				}

				IAgSearchResultCollection results = operand.Results;

				BisectionResult result = null;
                int resultIndex = 0;
				
				for (int i = 0; i < results.Count; ++i)
				{
					result = (BisectionResult)results[i];
					if ( result != null && result.IsActive )
					{
                        resultIndex = i;
						break;
					}
					result = null;
				}

				if (control == null || result == null)
				{
					// controls and results are not of the right type, or none are active
					m_UtPluginSite.Message(AgEUtLogMsgType.eUtLogMsgAlarm, "There must be one active control and one active result.");
					return false;
				}

                int count = 0;

                operand.Evaluate2(true); // the true flag lets the run appear on graphs
		
				double a = control.CurrentValue;
				double b = a;
				double fa = result.CurrentValue;
				double fb = fa;
		
				double step = control.Step;
				double desired = result.DesiredValue;
				double tolerance = result.Tolerance;
		
				// are we already within tolerance?
				if (Math.Abs(fa - desired) < tolerance)
				{
					return true;
				}
		
				if (testing)
				{
					// if we're testing we won't do any searching - ok, but return false
					return false;
				}

                // make the status grid
                operand.StatusGrid.CreateGrid(2, 6);
                operand.StatusGrid.SetColumnToTruncateLeft(0);
                operand.StatusGrid.SetColumnToTruncateLeft(2);
                operand.StatusGrid.SetHeaderCellString(0, 0, "Control Name");
                operand.StatusGrid.SetHeaderCellString(0, 1, "Control Value");
                operand.StatusGrid.SetHeaderCellString(0, 2, "Result Name");
                operand.StatusGrid.SetHeaderCellString(0, 3, "Result Value");
                operand.StatusGrid.SetHeaderCellString(0, 4, "Desired Value");
                operand.StatusGrid.SetHeaderCellString(0, 5, "Tolerance");

                operand.StatusGrid.SetCellString(1, 0, control.ObjectName + " : " + control.ControlName);
                operand.StatusGrid.SetCellString(1, 2, result.ObjectName + " : " + result.ResultName);
                operand.StatusGrid.SetCellResultValue(1, 4, resultIndex, desired, 8);
                // tolerance is in delta units
                operand.StatusGrid.SetCellResultDeltaValue(1, 5, resultIndex, tolerance, 8);

                operand.StatusGrid.SetStatus("Initial run");

		
				bool changedSign = false;
		
				bool bounded = false;
		
				// find the initial set that bounds zero
				while(!bounded && count < m_maxIters)
				{
                    ++count;

					a = b;
					fa = fb;
					b = a + step;
					control.CurrentValue = b;
		
					operand.Evaluate2(true);
		
					fb = result.CurrentValue;

                    operand.StatusGrid.SetCellControlValue(1, 1, controlIndex, b, 8);
                    operand.StatusGrid.SetCellResultValue(1, 3, resultIndex, fb, 8);
                    operand.StatusGrid.SetStatus("Iteration " + count + ": Searching for bounds");
                    operand.StatusGrid.Refresh();
			
					// see if b hit the desired value
					if (Math.Abs(fb - desired) < tolerance)
					{
                        operand.StatusGrid.SetStatus("Desired value reached while searching for bounds.");
                        operand.StatusGrid.Refresh();
						return true;
					}
			
					bounded = (fa > desired && fb < desired) || (fa < desired && fb > desired);
			
					// make sure we are getting closer to the desired value
					if ( !bounded && Math.Abs(fb - desired) >= Math.Abs(fa - desired) )
					{
						// search in the other direction, unless we've already changed the step once
						if (!changedSign)
						{
							changedSign = true;
							step = -step;
							b = a;
							fb = fa;
						}
						else
						{
							// error out
                            operand.StatusGrid.SetStatus("Unable to bound desired value");
                            operand.StatusGrid.Refresh();
							Debug.WriteLine("Unable to bound desired value with given initial guess and step");
							return false;
						}
					}
				}
		
				double c = b;
				double fc = fb;
				while (Math.Abs(fc - desired) > tolerance && count < m_maxIters) 
				{
                    ++count;

					c = (a + b) / 2.0;
			
					control.CurrentValue = c;
			
					operand.Evaluate2(true);
			
					fc = result.CurrentValue;
			
					if ( (fc > desired && fa > desired) || (fc < desired && fa < desired))
					{
						a = c;
						fa = fc;
					}
					else
					{
						b = c;
						fb = fc;
					}

                    operand.StatusGrid.SetStatus("Iteration " + count + ": Searching for root");
                    operand.StatusGrid.SetCellControlValue(1, 1, controlIndex, c, 8);
                    operand.StatusGrid.SetCellResultValue(1, 3, resultIndex, fc, 8);
                    operand.StatusGrid.Refresh();
				}

                if (Math.Abs(fc - desired) > tolerance)
                {
                    operand.StatusGrid.SetStatus("Unable to converge within " + m_maxIters + " iterations.");
                    operand.StatusGrid.Refresh();
                    return false;
                }
                else
                {
                    operand.StatusGrid.SetStatus("Converged after  " + count + " iterations.");
                    operand.StatusGrid.Refresh();
                }
			}

			return true;
		}

		public void Free()
		{
		}

		public string GetControlsProgID(AgESearchControlTypes eType)
		{
			if (eType == AgESearchControlTypes.eSearchControlTypesReal)
			{
				return this.m_realControlsProgID;
			}
			else
			{
				return "";
			}
		}

		public string GetResultsProgID()
		{
			return this.m_resultsProgID;
		}

		#endregion

		#region IAgUtPluginConfig Interface Implementation
		public object GetPluginConfig( AgAttrBuilder builder )
		{
			try
			{
				Debug.WriteLine( "--> Entered", "GetPluginConfig()");

				if( builder != null )
				{
					if( this.m_AttrScope == null )
					{
						this.m_AttrScope = builder.NewScope();
				
						//====================
						// General Attributes
						//====================
						builder.AddStringDispatchProperty( this.m_AttrScope, "PluginName", "Human readable plugin name or alias", "Name", (int)AgEAttrAddFlags.eAddFlagReadOnly );
						builder.AddIntDispatchProperty( this.m_AttrScope, "MaxIterations", "Maximum Iterations", "MaxIterations", (int)AgEAttrAddFlags.eAddFlagNone );
					}

					string config;
					config = builder.ToString( this, this.m_AttrScope );
					Debug.WriteLine( "\n" + config, "GetPluginConfig()" );
				}
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", "GetPluginConfig()");
			}

			return this.m_AttrScope;
		}

		public void VerifyPluginConfig( AgUtPluginConfigVerifyResult result )
		{
			try
			{
				Debug.WriteLine( "Entered", "VerifyPluginConfig()");

				result.Result	= true;
				result.Message	= "Ok";
			}
			finally
			{
				Debug.WriteLine( "Exited", "VerifyPluginConfig()" );
			}
		}
		#endregion

        #region Registration functions
        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        [ComRegisterFunction]
        [ComVisible(false)]
        public static void RegisterFunction(Type t)
        {
            RemoveOtherVersions(t);
        }

        /// <summary>
        /// Called when the assembly is unregistered for use from COM.
        /// </summary>
        /// <param name="t">The type exposed to COM.</param>
        [ComUnregisterFunctionAttribute]
        [ComVisible(false)]
        public static void UnregisterFunction(Type t)
        {
            // Do nothing.
        }

        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// Eliminates the other versions present in the registry for
        /// this type.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        public static void RemoveOtherVersions(Type t)
        {
            try
            {
                using (RegistryKey clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID"))
                {
                    StringBuilder guidString = new StringBuilder("{");
                    guidString.Append(t.GUID.ToString());
                    guidString.Append("}");
                    using (RegistryKey guidKey = clsidKey.OpenSubKey(guidString.ToString()))
                    {
                        if (guidKey != null)
                        {
                            using (RegistryKey inproc32Key = guidKey.OpenSubKey("InprocServer32", true))
                            {
                                if (inproc32Key != null)
                                {
                                    string currentVersion = t.Assembly.GetName().Version.ToString();
                                    string[] subKeyNames = inproc32Key.GetSubKeyNames();
                                    if (subKeyNames.Length > 1)
                                    {
                                        foreach (string subKeyName in subKeyNames)
                                        {
                                            if (subKeyName != currentVersion)
                                            {
                                                inproc32Key.DeleteSubKey(subKeyName);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
                // Ignore all exceptions...
            }
        }
        #endregion
	}
}
//========================================================//
//     Copyright 2006-2010, Analytical Graphics, Inc.     //
//========================================================//