//========================================================//
//     Copyright 2006-2007, Analytical Graphics, Inc.     //
//========================================================//
using Microsoft.Win32;
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

using AGI.Attr;
using AGI.Plugin;
using AGI.Search;
using AGI.STK.Plugin;

namespace AGI.SearchControlReal.Plugin.Examples.CSharp.BisectionControlReal
{
	/// <summary>
	/// Bisection search example
	/// </summary>
	// NOTE: Generate your own Guid using Microsoft's GuidGen.exe
	[Guid("91E98E8E-00D9-4615-BBFC-BD4C08852C8B")]
	// NOTE: Create your own ProgId to match your plugin's namespace and name
	[ProgId("AGI.SearchControlReal.Plugin.Examples.CSharp.BisectionControlReal")]
	// NOTE: Specify the ClassInterfaceType.None enumeration, so the custom COM Interface 
	// you created, i.e. IExample1, is used instead of an autogenerated COM Interface.
	[ClassInterface(ClassInterfaceType.None)]
	public class BisectionControlReal :
		IBisectionControlReal,
		IAgSearchControlReal,
		IAgUtPluginConfig
	{
		#region Data Members

		private object							m_AttrScope		= null;

		#endregion
		
		#region Life Cycle Methods
		/// <summary>
		/// Constructor
		/// </summary>
		public BisectionControlReal()
		{
			try
			{
				Debug.WriteLine( "Entered", "BisectionControlReal()");

			}
			finally
			{
				Debug.WriteLine( "Exited", "BisectionControlReal()");
			}
		}

		/// <summary>
		/// Destructor
		/// </summary>
		~BisectionControlReal()
		{
			try
			{
				Debug.WriteLine( "Entered", "~BisectionControlReal()");
			}
			finally
			{
				Debug.WriteLine( "Exited", "~BisectionControlReal()");
			}
		}

		#endregion

		#region IBisectionControlReal Interface Implementation

		private double	m_step	= 100.0;
		private bool	m_active = false;

		public double Step
		{
			get
			{
				return this.m_step;
			}
			set
			{
				this.m_step = value;
			}
		}

		public bool IsActive
		{
			get
			{
				return this.m_active;
			}
			set
			{
				this.m_active = value;
			}
		}

		#endregion

		#region IAgSearchControlReal Interface Implementation

		private string m_objectName;
		private string m_controlName;
		private AgESearchControlTypes m_type;
		private double m_currentValue;
		private double m_initialValue;
		private string m_dimension;
		private string m_internalUnit;

		public string ObjectName
		{
			get
			{
				return this.m_objectName;
			}
			set
			{
				this.m_objectName = value;
			}
		}

		public string ControlName
		{
			get
			{
				return this.m_controlName;
			}
			set
			{
				this.m_controlName = value;
			}
		}

		public AgESearchControlTypes ControlType
		{
			get
			{
				return this.m_type;
			}
			set
			{
				this.m_type = value;
			}
		}

		public double CurrentValue
		{
			get
			{
				return this.m_currentValue;
			}
			set
			{
				this.m_currentValue = value;
			}
		}

		public double InitialValue
		{
			get
			{
				return this.m_initialValue;
			}
			set
			{
				this.m_initialValue = value;
			}
		}

		public string Dimension
		{
			get
			{
				return this.m_dimension;
			}
			set
			{
				// reset the attr scope so a new one will be made with the new dimension the next time
				// it is needed
				if (this.m_dimension != value)
				{
					this.m_AttrScope = null;
				}

				this.m_dimension = value;
			}
		}

		public string InternalUnit
		{
			get
			{
				return this.m_internalUnit;
			}
			set
			{
				this.m_internalUnit = value;
			}
		}

		#endregion

		#region IAgUtPluginConfig Interface Implementation
		public object GetPluginConfig( AgAttrBuilder builder )
		{
			try
			{
				Debug.WriteLine( "--> Entered", "GetPluginConfig()");

				if( builder != null )
				{
					if( this.m_AttrScope == null )
					{
						this.m_AttrScope = builder.NewScope();
				
						builder.AddBoolDispatchProperty ( this.m_AttrScope, "Active", "True if used by algorithn", "IsActive", (int)AgEAttrAddFlags.eAddFlagNone );

						// note: m_dimension and m_internalUnits are set by the plugin point before
						// this method is called
						if (m_dimension == "")
						{
							// dimensionless
							builder.AddDoubleDispatchProperty ( this.m_AttrScope, "Step", "Step used when searching for bounds", "Step", (int)AgEAttrAddFlags.eAddFlagNone );
						}
						else if (m_dimension == "DateFormat")
						{
							// the step is in timeUnits (seconds) if the control is a date
							builder.AddQuantityDispatchProperty ( this.m_AttrScope, "Step", "Step used when searching for bounds", "Step", "Seconds", "Seconds", (int)AgEAttrAddFlags.eAddFlagNone );
						}
						else
						{
							// attr quantity, use internal that were given
							builder.AddQuantityDispatchProperty ( this.m_AttrScope, "Step", "Step used when searching for bounds", "Step", m_internalUnit, m_internalUnit, (int)AgEAttrAddFlags.eAddFlagNone );
						}
					}

					string config;
					config = builder.ToString( this, this.m_AttrScope );
					Debug.WriteLine( "\n" + config, "GetPluginConfig()" );
				}
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", "GetPluginConfig()");
			}

			return this.m_AttrScope;
		}

		public void VerifyPluginConfig( AgUtPluginConfigVerifyResult result )
		{
			try
			{
				Debug.WriteLine( "Entered", "VerifyPluginConfig()");

				result.Result	= true;
				result.Message	= "Ok";
			}
			finally
			{
				Debug.WriteLine( "Exited", "VerifyPluginConfig()" );
			}
		}
		#endregion

        #region Registration functions
        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        [ComRegisterFunction]
        [ComVisible(false)]
        public static void RegisterFunction(Type t)
        {
            RemoveOtherVersions(t);
        }

        /// <summary>
        /// Called when the assembly is unregistered for use from COM.
        /// </summary>
        /// <param name="t">The type exposed to COM.</param>
        [ComUnregisterFunctionAttribute]
        [ComVisible(false)]
        public static void UnregisterFunction(Type t)
        {
            // Do nothing.
        }

        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// Eliminates the other versions present in the registry for
        /// this type.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        public static void RemoveOtherVersions(Type t)
        {
            try
            {
                using (RegistryKey clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID"))
                {
                    StringBuilder guidString = new StringBuilder("{");
                    guidString.Append(t.GUID.ToString());
                    guidString.Append("}");
                    using (RegistryKey guidKey = clsidKey.OpenSubKey(guidString.ToString()))
                    {
                        if (guidKey != null)
                        {
                            using (RegistryKey inproc32Key = guidKey.OpenSubKey("InprocServer32", true))
                            {
                                if (inproc32Key != null)
                                {
                                    string currentVersion = t.Assembly.GetName().Version.ToString();
                                    string[] subKeyNames = inproc32Key.GetSubKeyNames();
                                    if (subKeyNames.Length > 1)
                                    {
                                        foreach (string subKeyName in subKeyNames)
                                        {
                                            if (subKeyName != currentVersion)
                                            {
                                                inproc32Key.DeleteSubKey(subKeyName);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
                // Ignore all exceptions...
            }
        }
        #endregion
	}
}
//========================================================//
//     Copyright 2006-2007, Analytical Graphics, Inc.     //
//========================================================//