//========================================================//
//     Copyright 2006, Analytical Graphics, Inc.          //
//========================================================//
using Microsoft.Win32;
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

using AGI.Attr;
using AGI.Plugin;
using AGI.Search;
using AGI.STK.Plugin;

namespace AGI.SearchResult.Plugin.Examples.CSharp.BisectionResult
{
	/// <summary>
	/// Bisection search example
	/// </summary>
	// NOTE: Generate your own Guid using Microsoft's GuidGen.exe
	[Guid("7E2D92FC-D854-45d1-BD7D-B6688D7C8164")]
	// NOTE: Create your own ProgId to match your plugin's namespace and name
	[ProgId("AGI.SearchResult.Plugin.Examples.CSharp.BisectionResult")]
	// NOTE: Specify the ClassInterfaceType.None enumeration, so the custom COM Interface 
	// you created, i.e. IExample1, is used instead of an autogenerated COM Interface.
	[ClassInterface(ClassInterfaceType.None)]
	public class BisectionResult :
		IBisectionResult,
		IAgSearchResult,
		IAgUtPluginConfig
	{
		#region Data Members

		private object							m_AttrScope		= null;

		#endregion
		
		#region Life Cycle Methods
		/// <summary>
		/// Constructor
		/// </summary>
		public BisectionResult()
		{
			try
			{
				Debug.WriteLine( "Entered", "BisectionResult()");

			}
			finally
			{
				Debug.WriteLine( "Exited", "BisectionResult()");
			}
		}

		/// <summary>
		/// Destructor
		/// </summary>
		~BisectionResult()
		{
			try
			{
				Debug.WriteLine( "Entered", "~BisectionResult()");
			}
			finally
			{
				Debug.WriteLine( "Exited", "~BisectionResult()");
			}
		}

		#endregion

		#region IBisectionResult Interface Implementation

		private double	m_desiredValue = 0.0;
		private double	m_tolerance = 0.01;
		private bool	m_active = false;

		public double DesiredValue
		{
			get
			{
				return this.m_desiredValue;
			}
			set
			{
				this.m_desiredValue = value;
			}
		}

		public double Tolerance
		{
			get
			{
				return this.m_tolerance;
			}
			set
			{
				this.m_tolerance = value;
			}
		}

		public bool IsActive
		{
			get
			{
				return this.m_active;
			}
			set
			{
				this.m_active = value;
			}
		}

		#endregion

		#region IAgSearchResult Interface Implementation

		private string m_objectName;
		private string m_resultName;
		private double m_currentValue;
		private bool   m_valid;
		private string m_dimension;
		private string m_internalUnit;

		public string ObjectName
		{
			get
			{
				return this.m_objectName;
			}
			set
			{
				this.m_objectName = value;
			}
		}

		public string ResultName
		{
			get
			{
				return this.m_resultName;
			}
			set
			{
				this.m_resultName = value;
			}
		}

		public double CurrentValue
		{
			get
			{
				return this.m_currentValue;
			}
			set
			{
				this.m_currentValue = value;
			}
		}

		public bool IsValid
		{
			get
			{
				return this.m_valid;
			}
			set
			{
				this.m_valid = value;
			}
		}

		public string Dimension
		{
			get
			{
				return this.m_dimension;
			}
			set
			{				
				// reset the attr scope so a new one will be made with the new dimension the next time
				// it is needed
				if (this.m_dimension != value)
				{
					this.m_AttrScope = null;
				}

				this.m_dimension = value;
			}
		}

		public string InternalUnit
		{
			get
			{
				return this.m_internalUnit;
			}
			set
			{
				this.m_internalUnit = value;
			}
		}

		#endregion

		#region IAgUtPluginConfig Interface Implementation
		public object GetPluginConfig( AgAttrBuilder builder )
		{
			try
			{
				Debug.WriteLine( "--> Entered", "GetPluginConfig()");

				if( builder != null )
				{
					if( this.m_AttrScope == null )
					{
						this.m_AttrScope = builder.NewScope();

						builder.AddBoolDispatchProperty ( this.m_AttrScope, "Active", "True if used by algorithn", "IsActive", (int)AgEAttrAddFlags.eAddFlagNone );
				
						// note: m_dimension and m_internalUnits are set by the plugin point before
						// this method is called
						if (m_dimension == "")
						{
							// dimensionless - desired value and tolerance are just attr doubles
							builder.AddDoubleDispatchProperty ( this.m_AttrScope, "DesiredValue", "Desired Value", "DesiredValue", (int)AgEAttrAddFlags.eAddFlagNone );
							builder.AddDoubleDispatchProperty ( this.m_AttrScope, "Tolerance", "Tolerance", "Tolerance", (int)AgEAttrAddFlags.eAddFlagNone );
						}
						else if (m_dimension == "DateFormat")
						{
							// date, set desired value as an attrDate and tolerance as an attrQuantity in seconds
							builder.AddDateDispatchProperty ( this.m_AttrScope, "DesiredValue", "Desired Value", "DesiredValue", (int)AgEAttrAddFlags.eAddFlagNone );
							builder.AddQuantityDispatchProperty ( this.m_AttrScope, "Tolerance", "Tolerance", "Tolerance", "Seconds", "Seconds", (int)AgEAttrAddFlags.eAddFlagNone );
						}
						else
						{
							// attr quantity, use internal units that were given
							builder.AddQuantityDispatchProperty ( this.m_AttrScope, "DesiredValue", "Desired Value", "DesiredValue", m_internalUnit, m_internalUnit, (int)AgEAttrAddFlags.eAddFlagNone );
							builder.AddQuantityDispatchProperty ( this.m_AttrScope, "Tolerance", "Tolerance", "Tolerance", m_internalUnit, m_internalUnit, (int)AgEAttrAddFlags.eAddFlagNone );
						}
					}

					string config;
					config = builder.ToString( this, this.m_AttrScope );
					Debug.WriteLine( "\n" + config, "GetPluginConfig()" );
				}
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", "GetPluginConfig()");
			}

			return this.m_AttrScope;
		}

		public void VerifyPluginConfig( AgUtPluginConfigVerifyResult result )
		{
			try
			{
				Debug.WriteLine( "Entered", "VerifyPluginConfig()");

				result.Result	= true;
				result.Message	= "Ok";
			}
			finally
			{
				Debug.WriteLine( "Exited", "VerifyPluginConfig()" );
			}
		}
		#endregion

        #region Registration functions
        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        [ComRegisterFunction]
        [ComVisible(false)]
        public static void RegisterFunction(Type t)
        {
            RemoveOtherVersions(t);
        }

        /// <summary>
        /// Called when the assembly is unregistered for use from COM.
        /// </summary>
        /// <param name="t">The type exposed to COM.</param>
        [ComUnregisterFunctionAttribute]
        [ComVisible(false)]
        public static void UnregisterFunction(Type t)
        {
            // Do nothing.
        }

        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// Eliminates the other versions present in the registry for
        /// this type.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        public static void RemoveOtherVersions(Type t)
        {
            try
            {
                using (RegistryKey clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID"))
                {
                    StringBuilder guidString = new StringBuilder("{");
                    guidString.Append(t.GUID.ToString());
                    guidString.Append("}");
                    using (RegistryKey guidKey = clsidKey.OpenSubKey(guidString.ToString()))
                    {
                        if (guidKey != null)
                        {
                            using (RegistryKey inproc32Key = guidKey.OpenSubKey("InprocServer32", true))
                            {
                                if (inproc32Key != null)
                                {
                                    string currentVersion = t.Assembly.GetName().Version.ToString();
                                    string[] subKeyNames = inproc32Key.GetSubKeyNames();
                                    if (subKeyNames.Length > 1)
                                    {
                                        foreach (string subKeyName in subKeyNames)
                                        {
                                            if (subKeyName != currentVersion)
                                            {
                                                inproc32Key.DeleteSubKey(subKeyName);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
                // Ignore all exceptions...
            }
        }
        #endregion
	}
}
//========================================================//
//     Copyright 2006, Analytical Graphics, Inc.          //
//========================================================//